########################################################################################################################################################################################
exam ian 2024:
ISM Exam, January 26, 2024 (OpenSSL in C/C++) (4,5p)
Implement a C/C++ application for the following requirements:
1. Create a file named as name.txt to store your full name in text format. Compute and print out a SHA256 hash value into the running application console. The SHA-256 value will be displayed in hex format.
(0,5p)
2. Encrypt the file name.txt using AES-256 in CBC mode (2p):
▪ IV provided by the text file iv.txt and having the hex format to be imported into an internal buffer as
binary format.
▪ AES-256 bit key provided by the binary file named as aes.key.
The output encrypted file will be named as enc_name.aes. No other data will be encrypted (e.g. IV,
plaintext length and so forth) besides the content of name.txt.
3. To ensure the destination that no one is tampering with that value, digitally sign (computed for the
above SHA-256) the previous encrypted binary file with a RSA-1024 bit private key generated by your
application. Store the signature in another binary file named digital.sign. (2p)
Use the RSA-1024 bit private key to sign the file name.txt. Upload your binary signature file (digital.sign)
together with the RSA-1024 bit public key file.
To get the points, the digital signature must be validated during the assessment.
Write a C/C++ application to implement the above requirements (one single C/C++ source code file).
All the solutions will be cross-checked with MOSS from Stanford and very similar source code files will not
be evaluated.

########################################################################################################################################################################################
exam iun 2024:
ISM Exam, July 2, 2024 (OpenSSL in C/C++)
Consider the following requirements to sign a plaintext and identify the right RSA private key for that
signature (2p):
1. Decrypt the files privateKey_1.enc, privateKey_2.enc and privateKey_3.enc to restore 3 RSA
private keys by considering:
 AES-ECB as crypto algorithm for decryption.
 AES-ECB key in hex format:
0xff, 0xff, 0xff, 0xff, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x10, 0x11, 0x12
 RSA private key size is 1024 bits.
 RSA private keys are in PEM format.
 The actual size of each PEM RSA restored key file is 887 bytes.
2. Use each PEM RSA restored private key to sign the plaintext in.txt by considering: (2p):
 Message digest algorithm is SHA-256.
 Padding type is RSA_PKCS1_PADDING.
3. Use the signature stored by eSign.sig to identify the right RSA private key used to generate it.
Print out the information regarding the RSA private key used to generate eSign.sig. (0,5p)
Write a C/C++ application to implement the above requirements (one single C/C++ source code file).
All the solutions will be cross-checked with MOSS from Stanford and very similar source code files will not
be evaluated.

########################################################################################################################################################################################
colocviu 2025:
Write a C/C++ application (one single source code file) using OpenSSL library to:
1. (3p) Sign each SHA-256 message digests extracted from the file Accounts.txt as
binary representation. The RSA private key RSAPrivateKey.pem is the same for all
SHA-256 messages. Save signaturesinto one single file called as AllSigns.sig where
one line corresponds to one single RSA signature.
2. (3p) Generate the signatures for both files Accounts.txt and AllSigns.sig. The
message digest algorithm is SHA-256 and the RSA private key is stored by
RSAPrivateKey.pem. Save both signatures into two separate files as Sign1.sig and
Sign2.sig.
3. (3p) Use the key stored by pass.key to encrypt both files Accounts.txt and
AllSigns.sig according to AES-ECB. Save the results into two separate files as
aes1.enc and aes2.enc.
All the solutions will be cross-checked with MOSS from Stanford. Solutions with a
similarity of more than 50% will be canceled.

########################################################################################################################################################################################
exam ian 2025:
ISM Exam January 31, 2025 (OpenSSL in C/C++)
Consider you have:
- Digital signature file signature.sig.
- A RSA key file named RSAKey.pem as the 1024-bit RSA key in PEM format.
- A list of password candidates in wordlist.txt.
Write a C/C++ application (one single source code file) using OpenSSL library to:
• Decrypt signature.sig to get the SHA-256 message digest. The RSA_PKCS1_PADDING padding has
been used to generate the RSA signature. Print out the hex format of SHA-256 (1 p)
• Compute the message digest according to SHA-256 for each word candidate after adding the salt
called ISMsalt at the end of the word candidate. Therefore, the input of hashing operation is the
word candidate concatenated with the salt. (1 p)
• Compare each SHA-256 message digest against the decrypted one. Print out the word candidate
(without salt) together with the line number where it is stored in the file wordlist.txt when the
comparison is true. (1 p)
• Encrypt the word candidate (without salt) found out at previous bullet. The result will be saved
into word.enc. The encryption algorithm is AES-CBC 256 bits, where the AES key is the SHA-256
obtained/calculated above. The IV content is { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 }. (1,5 p)
All the solutions will be cross-checked with MOSS from Stanford and very similar source code files will not
be evaluated.

########################################################################################################################################################################################
HOMEWORK 1:
Consider you have a list of pre-defined clear passwords stored by the file 10-million-password-list-top1000000.txt.
Write a C/C++ application (one single source code file) using OpenSSL development library to:
1. Identify the clear password having the SHA-1 message digest as
2e1a480670e31a5d015e28de043136b62e762d29 (as hex binary representation). The clear
password will be printed into the Console Application. The passwords stored by the file must be
treated as binary input for the message digest algorithm.
2. Create an output text file (pass_SHA1.txt) containing the all SHA-1 message digests in hex
representation (all hex pairs contain the both letters). Each line of the output file corresponds to
the clear password placed on the same line in the 10-million-password-list-top-1000000.txt.

########################################################################################################################################################################################
HOMEWORK 2:
Write a C/C++ application (one single source code file) using OpenSSL library to:
1. Perform AES-ECB encryption of the SHA-256 messages as binary representation extracted from
the file Accounts.txt. The AES key is stored by the file pass.key and it will be used as binary content
of the AES key file.
2. Save each encrypted SHA-256 message into a text file called SHA256_Enc.txt as hex
representation where each line contains one single SHA-256 encrypted message for the
corresponding line in Accounts.txt.

